#+STARTUP: INLINEIMAGES
#+STARTUP: hideblocks
# Local Variables:
# org-babel-default-header-args:python: ((:results . "output") (:exports . "code") (:cache))
# End:
#+begin_src emacs-lisp :session SINS
(pyvenv-workon "sim")
(setq python-shell-completion-native-enable nil)
#+end_src
#+begin_src python :session SINS
import simpy
import numpy as np
from async_communication import AsyncCommunication
import pandapower as pp
from random import randint
from uuid import uuid4
#+end_src

#+RESULTS:

#+TITLE Logging Development Progress on the Simulator
#+RESULTS:

* Preliminary Architecture
In order to model the operation of a smart grid, the simulator needs to operates asynchronously on a distributed architecture.
As a consequence a multi-agent design paradigm is probably a good way to describe it.

** The Generic Agent 

#+begin_src plantuml :file ./sim_arch.png :exports results
!definelong AGENT(name)
skinparam linetype ortho
component name {
component Scheduler as name.S
component AsyncComms as name.C
interface Consume as name.consume
interface Produce as name.produce
name.S <..> name.C : use
name.S -left-> name.consume
name.S -right-> name.produce
}
!enddefinelong
AGENT(Agent)
#+end_src

#+RESULTS:
[[file:./sim_arch.png]]

#+begin_src python :results output :session SINS
class Agent:
  """ A generic Network Agent.
  """
  def __init__(self, local=None, env=None):
    self.local = local
    if env is None:
      self.env = simpy.Environment()
    else:
      self.env = env
    self.comm = AsyncCommunication()

  def schedule(self, time, action):
    """ generates a production/consumption event
    """
    p = self.env.process(action, delay=time)
    return p
#+end_src

#+RESULTS:

#+begin_src plantuml :file ./sim_states.png :export results
skinparam linetype ortho
!definelong OPERATION(name)
[*] -> name##_OFF
name##_OFF -d-> name##_ON : start_##name
name##_ON -> name##_OFF : end_##name
!enddefinelong

state Communicating {
OPERATION(TX)
--
OPERATION(RX)
}

state Scheduling {
OPERATION(Production)
--
OPERATION(Consumption)
}
#+end_src

#+RESULTS:
[[file:./sim_states.png]]

#+begin_src plantuml :file alloc_agent_seq.png
box "Agent Allocator"
participant Scheduling as Alloc_Sched
participant Communicating as Alloc_Comm
end box
box "Agent 1"
participant Communicating as Agent_Comm
participant Scheduling as Agent_Sched
end box
Alloc_Sched -> Alloc_Comm: Schedule Operation
Alloc_Comm -> Agent_Comm: Schedule Operation
Agent_Comm -> Agent_Sched: Schedule Operation
Agent_Sched -> Agent_Comm: Report Operation
Agent_Comm -> Alloc_Comm: Report Operation
Alloc_Comm -> Alloc_Sched: Report Operation
#+end_src

#+RESULTS:
[[file:alloc_agent_seq.png]]


#+RESULTS:
[[file:class_diag.png]]


** The Allocator Agent
Contains the standard facilities of Scheduling and Communicating, wrapped around simpy and AsyncCommunication.
The allocator doesn't consume or produce per se, but generates production and consumption profiles corresponding for network elements (generators, loads ... etc).
The class definition bellow
#+begin_src plantuml :file alloc_class_diag.png
class Agent {
  schedule()
}
class NetworkAllocator {
  schedule()
  initialise()
  add_load()
  remove_load()
}
Agent <|-- NetworkAllocator
#+end_src 

#+RESULTS:
[[file:alloc_class_diag.png]]


#+begin_src python :results output :session SINS
class NetworkAllocator(Agent):
  """ Simulate a communicating policy allocator
  """
  def __init__(self):
    self.loads = {}
    super(NetworkAllocator, self).__init__()

  def initlise(self):
    pass

  def add_load(self, load):
    self.loads[load['id']] = load

  def remove_load(self, id):
    self.loads.popitem(id)

  def send_allocation(self, id , allocation):
    pass

  def run(self):
    self.schedule(action = send_allocation(id, allocation))
     
#+end_src

#+RESULTS:

** The Network Load Agent
#+begin_src plantuml :file load_class_diag.png
title **NetworkLoad class diagram**
class Agent {
  schedule()
}
class NetworkLoad {
  schedule()
  process_allocation()
  report_allocation()
}
Agent <|-- NetworkLoad
#+end_src 

#+RESULTS:
[[file:load_class_diag.png]]

#+begin_src plantuml :file sequence_txrx.png
title **Allocator-Agent interaction sequence-chart**
collections Allocator as A
collections Agent as B
A -> B: Beacon
B -> A: Join
A -> B: Joined
B -> A: Ack
A -> B: Allocation
B -> A: Ack
A -> B: ...
B -> A: ...
A -> B: Allocation
B -> A: Ack
#+end_src

#+RESULTS:
[[file:sequence_txrx.png]]

#+begin_src python :results output :session SINS
class NetworkLoad(Agent):
  def __init__(self, remote='127.0.0.1:5555', local='*:5000'):
    self.env = simpy.Environment()
    self.comm = AsyncCommunication()
    self.remote = remote
    self.local = local
 
  def receive_handle(self, data, src):
    
    allocation, duration=data['msg']
    self.schedule(time=0, action=send_ack(allocation, dst=src))
    self.schedule(time=0, action=allocation_handle(allocation, duration))
  
  def allocation_handle(self, allocation, duration):
    yield self.env.timeout(duration)

  def send_ack(self, allocation):
    packet={"allocation_id" : allocation['allocation_id'], "msg_type": "allocation_ack"}
    self.comm.send(packet)
#+end_src

#+RESULTS:
