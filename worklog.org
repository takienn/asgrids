#+TITLE Logging Development Progress on the Simulator
#+STARTUP: INLINEIMAGES
#+STARTUP: hideblocks
#+name setup
#+begin_src emacs-lisp :session SINS :exports none :results silent 
(pyvenv-workon "sim")
(setq python-shell-completion-native-enable nil)
(setq sphinx-doc-mode t)
#+end_src
# Local variables:
# eval: (org-sbe "setup)
# End:
#+begin_src python :tangle ./sins.py :session SINS :results none :exports none
import simpy
from async_communication import AsyncCommunication
#+end_src


* Preliminary Architecture
In order to model the operation of a smart grid, the simulator needs to operates asynchronously on a distributed architecture.
As a consequence a multi-agent design paradigm is probably a good way to describe it.

** The Generic Agent 
The generic agent translates to the basic class the implements the basic behavior of running an endless event loop (see <<generic_agent>>), and processing actions as they are scheduled.
The Agent interacts with the outside world through AsyncComms interface. This interface is implmented through various child classes the inherit from the Agent.
The interaction between the scheduling and AsyncComms interface is as can be seen in <<agents_seq>>.
The code block <<generic_agent_src>> shows an implementation of such an Agent.

#+NAME: generic_agent
#+begin_src plantuml :file ./generic_agent.png :exports none
!definelong AGENT(name)
skinparam linetype ortho
component name {
component Scheduler as name.S
component AsyncComms as name.C
interface Consume as name.consume
interface Produce as name.produce
name.S <..> name.C : use
name.S -left-> name.consume
name.S -right-> name.produce
}
!enddefinelong
AGENT(Agent)
#+end_src

#+RESULTS: generic_agent
[[file:./generic_agent.png]]


#+NAME: generic_agent_src
#+begin_src python :exports results :results output :tangle ./sins.py :session SINS
  # A generic Network Agent.
  class Agent:
      def __init__(self, env=None):
          """ Make sure a simulation environment is present and Agent is running.

          :param env: a simpy simulation environment
          """
          if env is None:
              self.env = simpy.Environment()
          else:
              self.env = env
          self.running = True
          self.env.process(self.run())
          self.env.run()

      def run(self):
          """ Starting the local simulation event loop
          To avoid executing run every time an event is scheduled,
          an empty event is infinitely scheduled
          """
          while self.running:
              yield self.env.timeout(1)

      def schedule(self, time, action):
          """ The agent's schedule function

          :param time: relative time from present to execute action
          :param action: the handle to the function to be executed at time.
          :returns: 
          :rtype: 

          """
          p = self.env.process(action, delay=time)
          return p

      def stop(self):
          """ stop the Agent by stop the local simpy environment.

          :returns: 
          :rtype: 

          """
          self.running = False
#+end_src

#+RESULTS: generic_agent_src

#+NAME: agents_seq
#+begin_src plantuml :exports none :file agents_seq.png
box "Agent Allocator"
participant Scheduling as Alloc_Sched
participant Communicating as Alloc_Comm
end box
box "Agent 1"
participant Communicating as Agent_Comm
participant Scheduling as Agent_Sched
end box
Alloc_Sched -> Alloc_Comm: Schedule Operation
Alloc_Comm -> Agent_Comm: Schedule Operation
Agent_Comm -> Agent_Sched: Schedule Operation
Agent_Sched -> Agent_Comm: Report Operation
Agent_Comm -> Alloc_Comm: Report Operation
Alloc_Comm -> Alloc_Sched: Report Operation
#+end_src

#+RESULTS: agents_seq
[[file:agents_seq.png]]

** The Allocator Agent
Contains the standard facilities of Scheduling and Communicating, wrapped around simpy and AsyncCommunication.
The allocator doesn't consume or produce per se, but generates production and consumption profiles corresponding for network elements (generators, loads ... etc).
The class definition bellow
#+NAME allocator
#+begin_src plantuml :exports none :file allocator.png
class Agent {
  schedule()
}
class NetworkAllocator {
  initialise()
  add_load()
  remove_load()
}
Agent <|-- NetworkAllocator
#+end_src 

#+RESULTS:
[[file:allocator.png]]

#+NAME: allocator_src
#+begin_src python :tangle ./sins.py :results output :session SINS
  class NetworkAllocator(Agent):
      # Simulate a communicating policy allocator

      def __init__(self, local='*:5555'):
          self.local = local
          self.comm = AsyncCommunication()
          self.comm.run_server(callback=self.receive_handle, local_address=local)
          self.comm.start()
          self.loads = {}
          super(NetworkAllocator, self).__init__()

      def initialise(self):
          pass

      def receive_handle(self, data, src):
          """ Handle packets received and decoded at the AsyncCommunication layer.

          :param data: received payload
          :param src: source of payload
          :returns: 
          :rtype: 

          """
          msg_type = data['msg_type']
          if msg_type == 'join':
              agent_id = data['agent_id']
              allocation = data['allocation']
              self.add_load(load_id=agent_id, allocation=allocation)
              self.schedule(time=0, action=self.send_join_ack(dst=src))
          elif msg_type == 'allocation_ack':
              agent_id = data['agent_id']
              allocation = data['allocation']
              self.add_load(load_id=agent_id, allocation=allocation)
          elif msg_type == 'leave':
              agent_id = data['agent_id']
              self.remove_load(load_id=agent_id)

      def add_load(self, load_id, allocation):
          """ Add a network load to Allocator's known loads list.

          :param load_id: id of load to be added (used as a dictionary key)
          :param allocation: the load's reported allocation when added.
          :returns: 
          :rtype: 

          """
          self.loads[load_id] = allocation

      def remove_load(self, load_id):
          """ Remove a load from Allocator's known loads list.

          :param load_id: id (key) of load to be removed.
          :returns: The removed load.
          :rtype: 

          """
          return self.loads.pop(load_id, None)

      def send_allocation(self, agent_id, allocation):
          """ Send an allocation to a Network's load

          :param agent_id: id of destination load
          :param allocation: allocation to be sent
          :returns: 
          :rtype: 

          """
          packet = {'msg_type': 'allocation', 'allocation': allocation}
          self.schedule(action=self.comm.send(agent_id, packet))

      def send_join_ack(self, dst):
          """ Acknowledge a network load has joing the network (added to known loads list)

          :param dst: destination of acknowledgemnt, should be the same load who requested joining.
          :returns: 
          :rtype: 

          """
          packet = {'msg_type': 'join_ack'}
          self.schedule(action=self.comm.send(packet, remote=dst))

      def stop(self):
          """ Stops the allocator, by first stop the AsyncComm interface then the parent Agent.

          :returns: 
          :rtype: 

          """
          self.env.process(self.comm.stop())
          self.env.process(super(NetworkAllocator, self).stop())
#+end_src

#+RESULTS: allocator_src

** The Network Load Agent
The Network Load models the behavior of an Agent that can handle Allocator commands to consume/produce specific allocations.
It inherits from the Generic Agents and interfaces with the outside world through the AsyncCommunication class.

#+NAME: load
#+begin_src plantuml :file load.png
title **NetworkLoad class diagram**
class Agent {
  schedule()
}
class NetworkLoad {
  schedule()
  process_allocation()
  receive_handle()
  allocation_handle()
  send_ack()
  stop()
}
Agent <|-- NetworkLoad
#+end_src 

#+RESULTS: load
[[file:load.png]]

#+NAME: load_state
#+begin_src plantuml :exports none :file load_state_diag.png
[*] -> run_loop
run_loop -d-> run_loop : no event
run_loop -d-> receive_handle: AsyncComm packet
receive_handle -> allocation_handle: packet is allocation
receive_handle -> run_loop: invalid packet \n join_ack packet
allocation_handle -> send_ack: allocation processed
allocation_handle -> run_loop: allocation not processed
send_ack -> run_loop: packet processed
run_loop -u-> [*]: stop event

#+end_src

#+RESULTS: load_state
[[file:load_state_diag.png]]

#+begin_src plantuml :exports none :file sequence_txrx.png
title **Allocator-Agent interaction sequence-chart**
collections Allocator as A
collections Agent as B
A -> B: Beacon
B -> A: Join
A -> B: Joined
B -> A: Ack
A -> B: Allocation
B -> A: Ack
A -> B: ...
B -> A: ...
A -> B: Allocation
B -> A: Ack
#+end_src

#+RESULTS:
[[file:sequence_txrx.png]]

#+NAME: load_src
#+begin_src python :tangle ./sins.py :results output :session SINS
  class NetworkLoad(Agent):
      def __init__(self, remote='127.0.0.1:5555', local='*:5000'):
          self.remote = remote
          self.local = local
          self.agent_id = self.local
          self.curr_allocation = 0
          self.comm = AsyncCommunication(identity=self.id)
          self.comm.run_server(callback=self.receive_handle, local_address=local)
          self.comm.start()
          super(NetworkLoad, self).__init__()

      def receive_handle(self, data, src):
          msg_type = data['msg_type']
          if msg_type == 'ack':
              return
          if msg_type == 'allocation':
              allocation = data['allocation']
              self.schedule(time=0, action=self.send_ack(allocation, dst=src))
              self.schedule(time=0, action=self.allocation_handle(allocation))

      def allocation_handle(self, allocation):
          duration = allocation['duration']
          value = allocation['allocation_value']
          print("Current load is {}".format(value))
          yield self.env.timeout(duration)

      def join_ack_handle(self):
          pass

      def send_join(self, dst):
          packet = {
              'agent_id': self.agent_id,
              'msg_type': 'join',
              'allocation': self.curr_allocation
          }
          self.schedule(time=0, action=self.comm.send(packet, remote=dst))

      def send_ack(self, allocation, dst):
          packet = {
              'agent_id': self.agent_id,
              "msg_type": "allocation_ack",
              "allocation": allocation.copy()
          }
          self.schedule(time=0, action=self.comm.send(packet, remote=dst))

      def stop(self):
          self.env.process(self.comm.stop())
          self.env.process(super(NetworkLoad, self).stop())
#+end_src

#+RESULTS: load_src
